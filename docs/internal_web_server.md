# Internal WWW Server

## Quick Reference: how to run it and extend it 

* to run the internal web server : `gulp serve`
* to add new content to the web server: create a new file in `theSrc/internal_www/content` using the [content_template](https://github.com/Displayr/rhtmlTemplate/blob/master/theSrc/internal_www/content/content_template.html), or add an example to an existing content file IF IT FITS (dont mix concerns in your files)

## Objectives

There are multiple objectives served by maintaining a set of internal content for each html widget:

* **Allow visual regression testing** : We can compare the content generated by two versions of the code to determine if anything unexpected has changed. This can be done manually via inspection of the content, or automatically using the [visual regression test suite](./visual_regression_testing.md).
* **Allow interaction testing** : We can write test that interact with the widget in the browser and verify certain things happen and the the final state matches a visual regression snapshot  
* **Real time feedback during dev** : This allows a workflow where I write up a config for a widget that doesn't currently support what I am trying to do, then I start writing the code to support the new feature. Every time I save my work, the widget is redrawn, so I can see in real time how my work is progressing.
* **Maintain live documentation** : Using the internal web server framework it is straightforward to build tutorial style documentation, and even snapshot that documentation to ensure your docs dont break. See the [rhtmlPictographs](https://github.com/Displayr/rhtmlPictographs) tutorial section when running gulp serve in the rhtmlPictographs repo for a good example.

### Why hav an internal web server ?

At first glance in the widget repos you see quite a bit of non production code so worth explaining why it is worth it. Consider the following scenario where I begin to add feature X to my widget. I add an example called _**feature X WIP**_ to the internal_www content area (i.e., /theSrc/internal_www/content) area. I run `gulp serve`, and navigate to the _**feature X WIP**_ example. It doesn't work :(. This makes sense though because I haven't even written the code yet ! I make a series of changes to implement feature X. Every time I save an update to my project files, gulp auto builds the code, and sends a reload signal to my browser. I am literally seeing the visual effects of my code changes in real time. _**This is really good**_.
 
## How the browser area is built

The internal web server is just hosting all the files in the `browser` area, which is an auto generated section of the repo. Several gulp steps work in conjunction to build the content in the `browser` directory and serve it at http://127.0.0.1:9000. The 'important' ones are described below:
 
* the `compileRenderContentPage` and `compileRenderIndexPage` steps compiles ES6 into ES5 for the browser
* the `copy` step copies all the html and image files from `theSrc/internal_www` into the `browser` area
* the `buildContentManifest` step recursively scans the `browser/content` area and produces a manifest of all the content files in the area. This is used to build the index page that is displayed on http://127.0.0.1. Without this step the author would need to keep this list up to date by manual updates to the index.html file.
* the `connect` step starts a static content web server hosting all the files in the `browser` directory and makes them available on port 9000 of localhost (i.e., http://127.0.0.1:9000).
* the `watch` step runs constantly and monitors all the source code and content files. Any time the files are saved, the `watch` step will rerun one of the other build steps to update the content, and then send a signal to the browser to force a page reload.
 
## How a widget is rendered in the internal web server area

Using the content file [theSrc/internal_www/content/examples/default.html](https://github.com/Displayr/rhtmlTemplate/blob/master/theSrc/internal_www/content/examples/default.html) as an example we will now go through how the widget gets drawn. Note this only applies when viewing a widget at `http://127.0.0.1:9000` (i.e., the **internal** web server). For notes on how htmlwidgets work with R, see [how the code works](https://github.com/Displayr/rhtmlTemplate/blob/master/docs/how_the_code_works.md). 

* the [renderContentPage.js](https://github.com/Displayr/rhtmlTemplate/blob/master/theSrc/internal_www/js/renderContentPage.js) script is a bundled JS file that contains all the widget code, all the dependencies, and some code that is only used in the internal web server.
* Once the web page is loaded, the renderContentPage.js code scans the HTML content for DOM elements with a `class="example"`. 
* For each example, it retrieves the widget config, and widget user state if provided, then builds a widget by calling the widget code using the same methods that the HtmlWidget library would use.

## Web Server Content Features

There are several features provided by [renderContentPage.js](https://github.com/Displayr/rhtmlTemplate/blob/master/theSrc/internal_www/js/renderContentPage.js) that should be discussed. 

It is easiest to grasp by looking at an example in the rhtmlTemplate app:
 
* look at the source of the example : [example_of_content_page_features.html](https://github.com/Displayr/rhtmlTemplate/blob/master/theSrc/internal_www/content/tutorials/example_of_content_page_features.html). 
* After running `gulp serve` (in the rhtmlTemplate project, not in the rhtmlBuildUtils project), you can view the page [http://localhost:9000/content/tutorials/example_of_content_page_features.html](http://localhost:9000/content/tutorials/example_of_content_page_features.html).
 
**The web server content features:** 

The default width and height of a widget is 200 x 200. Each example can specify the width and height by using the `data-width` and `data-height` attributes.

You can line up examples in a row by wrapping them in a `<div class="row">` as shown in the first image below.

![data-inline-config-vary-width-example][vary-size-inline-config]


The widget config can be specified inline or as a reference to a file. The widget user state can also be provided as a reference to a file

![data-file-reference][file-reference]


By default the config is hidden, but if the `data-show-config` attribute is used, then the config will be displayed above the widget. 

![data-show-config-example][show-config]


A border can be drawn around the widget to show its boundaries by adding a `data-border=true` attribute to the example

![data-border-example][data-border-example]


A rerender control can be added by adding a `data-rerender` attribute to the example  

![data-rerender-example][data-rerender-example]


Resize controls can shown by adding a `data-resize-controls` attribute to the example.  

![data-resize-example][data-resize-example]

### Snapshots

Any DOM that has a `snapshot-name="SNAPSHOT_NAME"` attribute will cause the applitools integration to take a snapshot when the [visual regression test suite](./visual_regression_testing.md) is run (more on this below).

Note that adding `snapshot-name` also changes the css `display` property to `inline-block`, which affects the layout of the content. This is done so that the width of the container is limited to the content inside, instead of the full availalbe browser width. In other words: Applitools wants a fixed box, `display: inline-block` provides this. As a result, it's better to wrap your examples with a new `<div snapshot-name="NAME">` instead of adding the `snapshot-name` attribute directly to your examples.

[vary-size-inline-config]: /docs/resources/data-inline-config-vary-width-example.png
[file-reference]: /docs/resources/data-file-reference.png
[show-config]: /docs/resources/data-show-config-example.png
[data-border-example]: /docs/resources/data-border-example.png
[data-rerender-example]: /docs/resources/data-rerender-example.png
[data-resize-example]: /docs/resources/data-resize-example.png

## The renderExample.html page

The features provided by `renderContentPage.js` are listed above. Using `renderContentPage.js` we can write some HTML markup that causes widgets to be rendered. An alternative approach is to use `renderExample.html`, which will take all arguments as query parameters and render a single widget. This is useful for automated testing because we do not need to craft a HTML page to render a widget, instead we just pass arguments to `renderExample.html.

When `gulp serve` is running the `rtenderExample.html` page is available at this URL : [http://localhost:9000/renderExample.html]

The page accepts these parameters:

* width: set the widget width
* height: set the widget height
* config: set the widget config : the config will be retrieved from ./theSrc/internal_www/data/<config_name>/config.json
* state: set the widget state : the state will be retrieved from ./theSrc/internal_www/data/<config_name>/<state>.json
* rerenderControls: if set to true then add rerender controls to the page